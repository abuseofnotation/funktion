
---
category: tutorial
title: maybe monad
layout: post
---

The `maybe` type, also known as `option` type is a container for a value that may or not be there. 

The purpose of this monad is to eliminate the need for writing `null` checks. furthermore it also eliminates the possibility of making errors by missing null-checks.

<!--more-->





To use the `maybe` monad constructor, you can require it using node:
		
		var maybe = require("../library/maybe")


Where the `../` is the location of the module.

Then you will be able to wrap a value in `maybe` with:

		var maybe_val = maybe(val)

If the 'val' is equal to *undefined* it threats the container as empty.


map(funk)
----
Executes the function with the `maybe`'s value as an argument, but only if the value is different from *undefined*.




If you have access to a value that may be undefined you have to do a null check before doing something with it:


	var get_property = f((object) => object.property)
	
	var val = get_property(obj)
	
	if(val !== undefined){
		val = val.toString()
	}
	assert.equal(val, undefined) 

However we may easily forget the null check
	
	assert.throws(function(){
		get_property(obj).toString()  //this blows up
	})
    
if you use **maybe** you cannot access the underlying value directly, and therefore you cannot execute an action on it, if it is not there.

 	var maybe_get_property = get_property.map(maybe)

	var function_called = false
	maybe_get_property(obj).map((val) => {
		assert.ok(false)
		val.toString()//this is not executed
	})



flatMap(funk)
----
Same as map, but allows for nes




	var get = f((prop, obj) => obj[prop])

	var obj = { first: {second:{third:"val"} } }
	
	maybe(obj)
		.flatMap((obj) => maybe(obj.first))
		.flatMap((obj) => maybe(obj.second))
		.flatMap((obj) => maybe(obj.third))
		.flatMap((val) => {
			assert.equal(val, "val")
		})
	
	var maybe_get = get.map(maybe)


	

})




var helpers = require("./helpers")
                                            
Under the hood                                
--------------                                
Let's see how this type is implemented     
                                            



the `of` method, takes a value and wraps it in a `maybe`.
In this case we do this by just calling the constructor.

	//a -> m a
	of:function(input){
		return maybe(input)
	},

`map` takes the function and applies it to the value in the maybe, if there is one.

	//m a -> ( a -> b ) -> m b
	map:function(funk){
		if(this !== nothing){
			return maybe(funk(this._value))
		}else{	
			return this 
		}
	},

'flat' takes a maybe that contains another maybe and flattens it.
In this case this means just returning the inner value.

	//m (m x) -> m x
	flat:function(){
		if(this !== nothing){
			return this._value
		}else{
			return this
		}
	},

finally we have `tryFlat` which does the same thing, but checks the types first. The shortcut to `map().tryFlat()` is called `phatMap` 

	tryFlat:function(){
		if(this !== nothing && this._value.constructor === maybe){
			return this._value
		}else{
			return this
		}
	}
	


In case you are interested, here is how the maybe constructor is implemented

var maybe = function(value){
	if (value === undefined){
		return nothing
	}else{
		var obj = Object.create(maybe_proto)
		obj._value = value
		obj.constructor = maybe
		Object.freeze(obj)
		return obj
	}
}







