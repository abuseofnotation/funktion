{
  "version": 3,
  "sources": [
    "node_modules/grunt-browserify/node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "library/core/compose.js",
    "library/core/core.js",
    "library/core/curry.js",
    "library/core/map.js",
    "library/funktion.js",
    "library/monads/bind.js",
    "library/monads/compose.js",
    "library/monads/monads.js",
    "library/objects/either.js",
    "library/objects/maybe.js",
    "library/objects/objects.js",
    "library/objects/state.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "module.exports = function(){\r\n\r\n\t//Convert functions to an array and flip them (for right-to-left execution)\r\n\tvar functions = Array.prototype.slice.call(arguments).reverse()\r\n\t//Check if input is OK:\r\n\tfunctions.forEach(function(funk){if(typeof funk !== \"function\"){throw new TypeError(funk+\" is not a function\" )}})\r\n\t//Return the function which composes them\r\n\treturn function(){\r\n\t\t//Take the initial input\r\n\t\tvar input = arguments\r\n\t\tvar context\r\n\t\treturn functions.reduce(function(return_result, funk, i){ \r\n\t\t\t//If this is the first iteration, apply the arguments that the user provided\r\n\t\t\t//else use the return result from the previous function\r\n\t\t\treturn (i ===0?funk.apply(context, input): funk(return_result))\r\n\t\t\t//return (i ===0?funk.apply(context, input): funk.apply(context, [return_result]))\r\n\t\t}, undefined)\r\n\t}\r\n}",
    "module.exports = {\r\n\tcompose:require(\"./compose\"),\r\n\tcurry:require(\"./curry\"),\r\n\tmap:require(\"./map\"),\r\n\tid:function(a){return a;}\r\n}\r\n",
    "module.exports = function curry(funk, initial_arguments){\r\n\tvar context = this\r\n\treturn function(){  \r\n\t\tvar all_arguments = (initial_arguments||[]).concat(Array.prototype.slice.call(arguments, 0))\r\n\t\treturn all_arguments.length>=funk.length?funk.apply(context, all_arguments):curry(funk, all_arguments)\r\n\t}\r\n}",
    "var curry = require(\"./curry\")\r\nmodule.exports = curry(function(funk, monad){\r\n\t\tif(typeof funk!==\"function\"){throw funk+\" is not a function\"}\r\n\t\tif(typeof monad.map!==\"function\"){throw monad+\" is not a monad\"}\r\n\t\treturn monad.map(funk)\r\n}) ",
    "var monads = require(\"./monads/monads\")\r\nvar core = require(\"./core/core\")\r\nvar objects = require(\"./objects/objects\")\r\nmodule.exports = {\r\n\tm:monads,\r\n\tf:core,\r\n\to:objects\r\n}\r\n\r\n\r\nwindow.f = core\r\nwindow.m = monads\r\nwindow.o = objects",
    "var f = require(\"../core/core\")\r\nmodule.exports = f.curry(function(funk, monad){\r\n\t\tif(typeof funk!==\"function\"){throw funk+\" is not a function\"}\r\n\t\tif(typeof monad.bind!==\"function\"){throw monad+\" is not a monad\"}\r\n\t\treturn monad.bind(funk)\r\n})",
    "var f = require(\"../core/core\")\r\nvar bind = require(\"./bind.js\")\r\n\r\nmodule.exports = function(){\r\n\tvar args = Array.prototype.map.call(arguments, function(funk){ return bind(funk)})\r\n\treturn f.compose.apply(this, args) \r\n\r\n}",
    "module.exports = {\r\n\tbind:(require(\"./bind\")),\r\n\tcompose:(require(\"./compose\"))\r\n}\r\nwindow.m = module.exports\r\n",
    "module.exports = {\r\n\t//a -> m a\r\n\tpure:function(right){\r\n\t\treturn {_right:right}\r\n\t},\r\n\t//m a -> ( a -> b ) -> m b\r\n\tmap:function(val, funk){\r\n\t\tnew_right = (val._right!==undefined)?funk(val._right):undefined\r\n\t\treturn {_left:val._left, _right:new_right}\r\n\t},\r\n\t//m (m x) -> m x \r\n\tjoin:function(val){\r\n\t\tvar new_val\r\n\t\tif(val._right!==undefined){\r\n\t\t\tnew_val = val._right\r\n\t\t}else{\r\n\t\t\tnew_val = {_left:val._left}\r\n\t\t}\r\n\t\treturn new_val\r\n\t}\r\n}\r\n",
    "module.exports = {\r\n\t//a -> m a\r\n\tof:function(input){\r\n\t\tthis._value = input;\r\n\t\treturn this;\r\n\t},\r\n\t//m a -> ( a -> b ) -> m b\r\n\tmap:function(funk){\r\n\t\treturn this.of((!(this._value instanceof Error))?funk(this._value):this._value)\r\n\t},\r\n\t//m (m x) -> m x\r\n\tjoin:function(){\r\n\t\tif(!(this._value instanceof Error)){\r\n\t\t\tif(Object.getPrototypeOf(this) !==Object.getPrototypeOf(this._value)){throw \"Illegal join operation.\"}\r\n\t\t\treturn this.of(this._value._value)\r\n\t\t}\r\n\t\treturn this.of(this._value)\r\n\t}\r\n\t\r\n\t//\r\n\t\r\n}\r\n",
    "var f = require(\"../core/core\")\r\nfunction create_type(methods){\r\n\t//Replace the 'of' function with a one that returns a new object\r\n\tvar of = methods.of\r\n\tmethods.of = function(a,b,c,d){return of.apply(Object.create(methods), arguments)}\r\n\t\r\n\t//\"chain\" AKA \"bind\" is equivalent to map . join \r\n\tif(!methods.bind && typeof methods.map ===\"function\" && typeof methods.join ===\"function\"){\r\n\t\tmethods.chain = methods.bind = function(funk){if(funk===undefined){throw \"function not defined\"}; return this.map(funk).join()}\r\n\t//'map' is equivalent of bind . of\r\n\t}else if(!methods.map && typeof methods.bind ===\"function\"){\r\n\t\tmethods.map = function(funk){return this.bind()}\r\n\t}\r\n\r\n\treturn methods;\r\n}\r\n\r\nmodule.exports = {\r\n\tstate:create_type(require(\"./state\")),\r\n\tmaybe:create_type(require(\"./maybe\")),\r\n}\r\n",
    "var f = require(\"../core/core\")\r\nmodule.exports = {\r\n\t//a -> m a\r\n\tof:function(input, state){\r\n\t\tthis._value = input;\r\n\t\tthis._state = state||f.id;\r\n\t\treturn this;\r\n\t},\r\n\t//m a -> ( a -> b ) -> m b\r\n\tmap:function(funk){\r\n\t\treturn this.of(funk(this._value), this._state)\r\n\t},\r\n\t\r\n\trun:function(){\r\n\t\treturn this._state({})\r\n\t},\r\n\t\r\n\t\r\n\t//m (m x) -> m x\r\n\t/*\r\n\t\r\n\t{\r\n\t\t_value:{\r\n\t\t\t_value:x,\r\n\t\t\t_state:s2\r\n\t\t}\r\n\t\tstate:s1\r\n\t}\r\n\t\r\n\tbecomes:\r\n\t\r\n\t{\r\n\t\t_value:x,\r\n\t\tstate: compose(s1,s2)\r\n\t}\r\n\t\r\n\t*/\r\n\tjoin:function(){\r\n\t\treturn this.of(this._value._value, f.compose(this._state, this._value._state ))\r\n\t}\r\n\t\r\n}"
  ]
}